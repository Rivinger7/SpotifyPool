using BusinessLogicLayer.Implement.CustomExceptions;
using BusinessLogicLayer.Interface.Services_Interface.JWTs;
using DataAccessLayer.Interface.MongoDB.UOW;
using DataAccessLayer.Repository.Entities;
using Microsoft.IdentityModel.Tokens;
using MongoDB.Driver;
using SetupLayer.Enum.Services.User;
using StackExchange.Redis;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace BusinessLogicLayer.Implement.Services.JWTs
{
    public class JwtBLL(IUnitOfWork unitOfWork, IConnectionMultiplexer redis) : IJwtBLL, IDisposable
    {
        private readonly IUnitOfWork _unitOfWork = unitOfWork;
        private readonly IDatabase _redis = redis.GetDatabase();
        private bool _disposed = false;

        public void Dispose()
        {
            if (!_disposed)
            {
                (_unitOfWork as IDisposable)?.Dispose();
                _disposed = true;

                // Ngăn Garbage Collector gọi Finalizer nếu có
                GC.SuppressFinalize(this);
            }
        }

        /// <summary>
        /// Generate access token with claims (user's informations)
        /// </summary>
        /// <param name="claims">A list of Claim having user information</param>
        /// <returns>A string of token which generated by Claim list</returns>
        private string GenerateAccessToken(IEnumerable<Claim> claims)
        {

            //int expireMinutes = 10; //set default expire time is 60 minutes
            int expiresInDays = 1; //set default expire time is 7 days

            //get secret key from appsettings.json
            var secretKey = Environment.GetEnvironmentVariable("JWTSettings_SecretKey") ?? throw new DataNotFoundCustomException("JWT's Secret Mode property is not set in environment or not found");

            //convert secret key to byte array
            var symmetricKey = Encoding.UTF8.GetBytes(secretKey);

            //create token with JwtSecurityTokenHandler
            var tokenHandler = new JwtSecurityTokenHandler();

            var tokenDescriptor = new JwtSecurityToken(
                //issuer: "https://localhost:7018", //set issuer is localhost

                //audience: "https://localhost:7018", //set audience is localhost

                claims: claims,

                expires: DateTime.Now.Add(TimeSpan.FromDays(expiresInDays)),

                signingCredentials: new SigningCredentials(
                                    new SymmetricSecurityKey(symmetricKey),
                                    SecurityAlgorithms.HmacSha256Signature) //use HmacSha256Signature algorithm to sign token
            );
            //write token with tokenDescriptor above
            var token = tokenHandler.WriteToken(tokenDescriptor);
            return token;
        }

        /// <summary>
        /// Refresh access token for expired token
        /// </summary>
        /// <returns></returns>
        private string GenerateRefreshToken(IEnumerable<Claim>? claims, ClaimsPrincipal? principal)
        {
            ////generate random number for refresh token
            //var randomNumber = new byte[32];

            ////use RandomNumberGenerator to create random number
            //using var rng = RandomNumberGenerator.Create();
            ////get random number and convert to base64 string
            //rng.GetBytes(randomNumber);
            //return Convert.ToBase64String(randomNumber);

            claims ??=
                [
                    new Claim(ClaimTypes.Name, principal.Identity?.Name ?? throw new ArgumentException("User's ID is not found in any session")),
                    new Claim(ClaimTypes.Role, principal.FindFirst(ClaimTypes.Role)?.Value ?? throw new ArgumentException("User's Role is not found in any session")),
                    new Claim("ArtistId", principal.FindFirst("ArtistId")?.Value ?? throw new ArgumentException("Artist's ID is not found in any session")),
                    new Claim(ClaimTypes.NameIdentifier, principal.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? throw new ArgumentException("User's ID is not found in any session")),
                    new Claim("Avatar", principal.FindFirst("Avatar")?.Value ?? throw new ArgumentException("User's Avatar is not found in any session")),
                ];

            int expireDays = 7; //set default expire time is 7 days

            string? refreshSecretKey = Environment.GetEnvironmentVariable("JWTSettings_RefreshTokenSecretKey") ?? throw new DataNotFoundCustomException("JWT's Secret refresh token is not set in environment or not found");

            var symmetricKey = Encoding.UTF8.GetBytes(refreshSecretKey);

            var tokenHandler = new JwtSecurityTokenHandler();

            var tokenDescriptor = new JwtSecurityToken(

                claims: claims,

                expires: DateTime.Now.Add(TimeSpan.FromMinutes(expireDays)),

                signingCredentials: new SigningCredentials(
                                    new SymmetricSecurityKey(symmetricKey),
                                    SecurityAlgorithms.HmacSha256Signature) //use HmacSha256Signature algorithm to sign token
            );

            var token = tokenHandler.WriteToken(tokenDescriptor);
            return token;
        }

        /// <summary>
        /// Method get all Claim with related user 
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        /// <exception cref="SecurityTokenException"></exception>
        private ClaimsPrincipal GetPrincipalFromExpiredToken(string? token)
        {
            //set token validation parameters
            TokenValidationParameters tokenValidationParameters = new()
            {
                ValidateAudience = false,

                ValidateIssuer = false,

                ValidateIssuerSigningKey = true,

                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Environment.GetEnvironmentVariable("JWTSettings_RefreshTokenSecretKey") ?? throw new DataNotFoundCustomException("JWT's Secret Mode property is not set in environment or not found"))), //Sign with encoded secret key

                ValidateLifetime = false //this field not need to check validate because we just want to get principal from that token
            };

            //get principal from token from tokenValidationParameters (information Claim in here)
            var tokenHandler = new JwtSecurityTokenHandler();
            var principal = tokenHandler.ValidateToken(token, tokenValidationParameters, out SecurityToken securityToken);

            //check if token is null or not and compare algorithm
            if (securityToken is not JwtSecurityToken jwtSecurityToken || !jwtSecurityToken.Header.Alg.Equals(SecurityAlgorithms.HmacSha256Signature, StringComparison.InvariantCultureIgnoreCase))
            {
                //throw exception if information in token is invalid
                throw new SecurityTokenException("Invalid token");
            }
            return principal;
        }



        /// <summary>
        /// Generate token Method in Service for API
        /// </summary>
        /// <param name="claims"></param>
        /// <param name="Id"></param>
        /// <param name="accessToken"></param>
        /// <param name="refreshToken"></param>
        public void GenerateAccessToken(IEnumerable<Claim> claims, string userId, out string accessToken, out string refreshToken)
        {
            //generate access token and refresh token
            accessToken = GenerateAccessToken(claims);

            refreshToken = GenerateRefreshToken(claims, null);

            //store refresh token to Redis
            _redis.StringSet(userId, refreshToken, TimeSpan.FromDays(7));

            return;
        }




        /// <summary>
        /// Revoke token Method in Service for API
        /// </summary>
        /// <param name="Id"></param>
        /// <exception cref="ErrorException"></exception>
        public async Task RevokeToken(string Id)
        {
            // Retrieve an user from the database
            User retrieveUser = await _unitOfWork.GetCollection<User>().Find(user => user.Id.ToString() == Id).FirstOrDefaultAsync() ?? throw new ArgumentException("Not found any available user");
        }

        //    // Update
        //    UpdateDefinition<User> refeshTokenUpdate = Builders<User>.Update.Set(user => user.RefreshToken, null);
        //    UpdateResult refeshTokenUpdateResult = await _unitOfWork.GetCollection<User>().UpdateOneAsync(user => user.Id.ToString() == Id, refeshTokenUpdate);

        //    return;
        //}




        /// <summary>
        /// Generate new access token and refresh token for user
        /// </summary>
        /// <param name="newAccessToken">out: put in argument</param>
        /// <param name="newRefreshToken">out: put in argument</param>
        /// <param name="principal">out: put in argument</param>
        /// <param name="oldRefreshToken">The refresh token which is store before</param>
        /// <exception cref="DataNotFoundCustomException"></exception>
        /// <exception cref="BadRequestCustomException"></exception>
        public void RefreshAccessToken(out string newAccessToken, out string newRefreshToken, out ClaimsPrincipal principal, string oldRefreshToken)
        {
            string refreshSecretKey = Environment.GetEnvironmentVariable("JWTSettings_RefreshTokenSecretKey") ?? throw new DataNotFoundCustomException("JWT refresh secret key is not set in environment or not found");


            principal = GetPrincipalFromExpiredToken(oldRefreshToken);

            string userID = principal.FindFirst(ClaimTypes.NameIdentifier)?.Value;

            RedisValue? tokenInRedis = _redis.StringGet(userID);

            if (tokenInRedis is null || tokenInRedis != oldRefreshToken)
            {
                throw new BadRequestCustomException("Invalid, refresh token is not available in cache! Please log in again.");
            }

            newAccessToken = GenerateAccessToken(principal.Claims);
            newRefreshToken = GenerateRefreshToken(principal.Claims, principal);

            //set lại refresh token và thời gian hết hạn mới
            _redis.StringSet(userID, newRefreshToken, TimeSpan.FromDays(7));
            return;
        }



        public string GenerateJWTTokenForConfirmEmail(string email, string encrpytedToken)
        {
            var jwtTokenHandler = new JwtSecurityTokenHandler();

            var secretKeyBytes = Encoding.UTF8.GetBytes(Environment.GetEnvironmentVariable("JWTSettings_SecretKey") ?? throw new DataNotFoundCustomException("JWT's Secret Mode property is not set in environment or not found"));

            var tokenDescription = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(
                [
                    new Claim("Email", email),
                    new Claim(ClaimTypes.Role, UserRole.Customer.ToString()),
                    new Claim("EncrpytedToken", encrpytedToken)
                ]),
                Expires = DateTime.UtcNow.AddHours(24),
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(secretKeyBytes), SecurityAlgorithms.HmacSha256Signature)
            };

            var token = jwtTokenHandler.CreateToken(tokenDescription);

            return jwtTokenHandler.WriteToken(token);
        }

        public JwtSecurityToken DecodeToken(string token)
        {
            var tokenHandler = new JwtSecurityTokenHandler();

            // Giải mã token JWT mà không cần xác thực
            var decodedToken = tokenHandler.ReadJwtToken(token);
            return decodedToken;
        }

        public ClaimsPrincipal ValidateToken(string token)
        {
            var tokenHadler = new JwtSecurityTokenHandler();
            string key = Environment.GetEnvironmentVariable("JWTSettings_SecretKey");

            TokenValidationParameters tokenValidationParameters = new()
            {
                ValidateAudience = false,

                ValidateIssuer = false,

                ValidateIssuerSigningKey = true,

                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(key) ?? throw new DataNotFoundCustomException("JWT's Secret Mode property is not set in environment or not found")),

                ValidateLifetime = false
            };



            //var tokenReader = tokenHadler.ReadJwtToken(token);
            //nếu secret key hợp lệ thì trả về claims chứa thông tin đã encode trong lúc tạo accesstoken
            return tokenHadler.ValidateToken(token, tokenValidationParameters, out _);
        }
    }
}
