using BusinessLogicLayer.Implement.CustomExceptions;
using BusinessLogicLayer.Interface.Services_Interface.JWTs;
using DataAccessLayer.Interface.MongoDB.UOW;
using DataAccessLayer.Repository.Entities;
using Microsoft.IdentityModel.Tokens;
using MongoDB.Driver;
using SetupLayer.Enum.Services.User;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace BusinessLogicLayer.Implement.Services.JWTs
{
    public class JwtBLL(IUnitOfWork unitOfWork) : IJwtBLL, IDisposable
    {
        private readonly IUnitOfWork _unitOfWork = unitOfWork;
        private bool _disposed = false;

        public void Dispose()
        {
            if (!_disposed)
            {
                (_unitOfWork as IDisposable)?.Dispose();
                _disposed = true;

                // Ngăn Garbage Collector gọi Finalizer nếu có
                GC.SuppressFinalize(this);
            }
        }

        /// <summary>
        /// Generate access token with claims (user's informations)
        /// </summary>
        /// <param name="claims">A list of Claim having user information</param>
        /// <returns>A string of token which generated by Claim list</returns>
        private static string GenerateAccessToken(IEnumerable<Claim> claims)
        {
            int expireMinutes = 10; //set default expire time is 60 minutes

            //get secret key from appsettings.json
            var secretKey = Environment.GetEnvironmentVariable("JWTSettings_SecretKey") ?? throw new DataNotFoundCustomException("JWT's Secret Mode property is not set in environment or not found");

            //convert secret key to byte array
            var symmetricKey = Encoding.UTF8.GetBytes(secretKey);

            //create token with JwtSecurityTokenHandler
            var tokenHandler = new JwtSecurityTokenHandler();

            var tokenDescriptor = new JwtSecurityToken(
                issuer: "https://localhost:7018", //set issuer is localhost

                audience: "https://localhost:7018", //set audience is localhost

                claims: claims,

                expires: DateTime.Now.Add(TimeSpan.FromMinutes(expireMinutes)),

                signingCredentials: new SigningCredentials(
                                    new SymmetricSecurityKey(symmetricKey),
                                    SecurityAlgorithms.HmacSha256Signature) //use HmacSha256Signature algorithm to sign token
            );
            //write token with tokenDescriptor above
            var token = tokenHandler.WriteToken(tokenDescriptor);
            return token;
        }

        /// <summary>
        /// Refresh access token for expired token
        /// </summary>
        /// <returns></returns>
        private static string GenerateRefreshToken(IEnumerable<Claim>? claims, ClaimsPrincipal? principal)
        {
            ////generate random number for refresh token
            //var randomNumber = new byte[32];

            ////use RandomNumberGenerator to create random number
            //using var rng = RandomNumberGenerator.Create();
            ////get random number and convert to base64 string
            //rng.GetBytes(randomNumber);
            //return Convert.ToBase64String(randomNumber);

            if (claims is null)
            {
                claims =
                [
                    new Claim(ClaimTypes.Name, principal.Identity?.Name ?? throw new ArgumentException("User's ID is not found in any session")),
                    new Claim(ClaimTypes.Role, principal.FindFirst(ClaimTypes.Role)?.Value ?? throw new ArgumentException("User's Role is not found in any session")),
                    new Claim(ClaimTypes.NameIdentifier, principal.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? throw new ArgumentException("User's ID is not found in any session")),
                    new Claim("Avatar", principal.FindFirst("Avatar")?.Value ?? throw new ArgumentException("User's Avatar is not found in any session")),
                ];
            }

            int expireDays = 7; //set default expire time is 60 minutes

            string? refreshSecretKey = Environment.GetEnvironmentVariable("JWTSettings_RefreshTokenSecretKey") ?? throw new DataNotFoundCustomException("JWT's Secret Mode property is not set in environment or not found");

            var symmetricKey = Encoding.UTF8.GetBytes(refreshSecretKey);

            var tokenHandler = new JwtSecurityTokenHandler();

            var tokenDescriptor = new JwtSecurityToken(

                claims: claims,

                expires: DateTime.Now.Add(TimeSpan.FromMinutes(expireDays)),

                signingCredentials: new SigningCredentials(
                                    new SymmetricSecurityKey(symmetricKey),
                                    SecurityAlgorithms.HmacSha256Signature) //use HmacSha256Signature algorithm to sign token
            );

            var token = tokenHandler.WriteToken(tokenDescriptor);
            return token;
        }

        /// <summary>
        /// Method get all Claim with related user 
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        /// <exception cref="SecurityTokenException"></exception>
        private static ClaimsPrincipal GetPrincipalFromExpiredToken(string? token)
        {
            //set token validation parameters
            TokenValidationParameters tokenValidationParameters = new()
            {
                ValidateAudience = false,

                ValidateIssuer = false,

                ValidateIssuerSigningKey = true,

                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Environment.GetEnvironmentVariable("JWTSettings_RefreshTokenSecretKey") ?? throw new DataNotFoundCustomException("JWT's Secret Mode property is not set in environment or not found"))), //Sign with encoded secret key

                ValidateLifetime = false //this field not need to check validate because we just want to get principal from that token
            };

            //get principal from token from tokenValidationParameters (information Claim in here)
            var tokenHandler = new JwtSecurityTokenHandler();
            var principal = tokenHandler.ValidateToken(token, tokenValidationParameters, out SecurityToken securityToken);

            //check if token is null or not and compare algorithm
            if (securityToken is not JwtSecurityToken jwtSecurityToken || !jwtSecurityToken.Header.Alg.Equals(SecurityAlgorithms.HmacSha256Signature, StringComparison.InvariantCultureIgnoreCase))
            {
                //throw exception if information in token is invalid
                throw new SecurityTokenException("Invalid token");
            }
            return principal;
        }


        /// <summary>
        /// Generate token Method in Service for API
        /// </summary>
        /// <param name="claims"></param>
        /// <param name="Id"></param>
        /// <param name="accessToken"></param>
        /// <param name="refreshToken"></param>
        public void GenerateAccessToken(IEnumerable<Claim> claims, string userId, out string accessToken, out string refreshToken)
        {
            //generate access token and refresh token
            accessToken = GenerateAccessToken(claims);

            refreshToken = GenerateRefreshToken(claims, null);

            DateTime refreshTokenExpiryTime = DateTime.Now.AddDays(7);

            UpdateDefinition<User> updateDefinition = Builders<User>.Update
                .Set(user => user.RefreshToken, refreshToken)
                .Set(user => user.RefreshTokenExpiryTime, refreshTokenExpiryTime);

            UpdateResult updateResult = _unitOfWork.GetCollection<User>().UpdateOne(
                user => user.Id == userId, updateDefinition);

            if (updateResult.ModifiedCount < 1)
            {
                throw new ArgumentException("Found User but cannot update");
            }

            return;
        }

        /// <summary>
        /// Revoke token Method in Service for API
        /// </summary>
        /// <param name="Id"></param>
        /// <exception cref="ErrorException"></exception>
        public async Task RevokeToken(string Id)
        {
            // Retrieve an user from the database
            User retrieveUser = await _unitOfWork.GetCollection<User>().Find(user => user.Id.ToString() == Id).FirstOrDefaultAsync() ?? throw new ArgumentException("Not found any available user");

            // Update
            UpdateDefinition<User> refeshTokenUpdate = Builders<User>.Update.Set(user => user.RefreshToken, null);
            UpdateResult refeshTokenUpdateResult = await _unitOfWork.GetCollection<User>().UpdateOneAsync(user => user.Id.ToString() == Id, refeshTokenUpdate);

            return;
        }


        /// <summary>
        /// Refresh token Method in Service for API
        /// </summary>
        /// <param name="newAccessToken"></param>
        /// <param name="newRefreshToken"></param>
        /// <param name="tokenApiModel"></param>
        /// <exception cref="ErrorException"></exception>
        public void RefreshAccessToken(out string newAccessToken, out string newRefreshToken, out ClaimsPrincipal principal, string oldRefreshToken)
        {
            string refreshSecretKey = Environment.GetEnvironmentVariable("JWTSettings_RefreshTokenSecretKey") ?? throw new DataNotFoundCustomException("JWT's Secret Mode property is not set in environment or not found");

            //Check if tokenApiModel is null or not
            //tokenApiModel = tokenApiModel ?? throw new ArgumentException("Please fill all of information");

            //string? accessToken = tokenApiModel.AccessToken;
            //string? refreshToken = tokenApiModel.RefreshToken;

            principal = GetPrincipalFromExpiredToken(oldRefreshToken);

            string userIDString = principal.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? throw new ArgumentException("User's ID is not found in any session"); //this is mapped to the Name claim by default

            //ObjectId userID = ObjectId.Parse(userIDString);
            string userID = userIDString;

            User retrieveUser = _unitOfWork.GetCollection<User>().Find(user => user.Id == userID).FirstOrDefault() ?? throw new ArgumentException("User's ID is not found");

            //check valid for refresh token and expiry time
            if (retrieveUser.RefreshToken == null || retrieveUser.RefreshToken != oldRefreshToken || retrieveUser.RefreshTokenExpiryTime <= DateTime.Now)
            {
                throw new ArgumentException("Refresh token is incorrect or user is invalid");
            }

            //generate new access token and refresh token
            newAccessToken = GenerateAccessToken(principal.Claims);
            newRefreshToken = GenerateRefreshToken(null, principal);

            UpdateDefinition<User> refeshTokenUpdate = Builders<User>.Update.Set(user => user.RefreshToken, newRefreshToken);
            UpdateResult refeshTokenUpdateResult = _unitOfWork.GetCollection<User>().UpdateOne(user => user.Id == userID, refeshTokenUpdate);
        }

        public string GenerateJWTTokenForConfirmEmail(string email, string encrpytedToken)
        {
            var jwtTokenHandler = new JwtSecurityTokenHandler();

            var secretKeyBytes = Encoding.UTF8.GetBytes(Environment.GetEnvironmentVariable("JWTSettings_SecretKey") ?? throw new DataNotFoundCustomException("JWT's Secret Mode property is not set in environment or not found"));

            var tokenDescription = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(
                [
                    new Claim("Email", email),
                    new Claim(ClaimTypes.Role, UserRole.Customer.ToString()),
                    new Claim("EncrpytedToken", encrpytedToken)
                ]),
                Expires = DateTime.UtcNow.AddHours(24),
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(secretKeyBytes), SecurityAlgorithms.HmacSha256Signature)
            };

            var token = jwtTokenHandler.CreateToken(tokenDescription);

            return jwtTokenHandler.WriteToken(token);
        }

        public JwtSecurityToken DecodeToken(string token)
        {
            var tokenHandler = new JwtSecurityTokenHandler();

            // Giải mã token JWT mà không cần xác thực
            var decodedToken = tokenHandler.ReadJwtToken(token);
            return decodedToken;
        }

        public ClaimsPrincipal ValidateToken(string token)
        {
            var tokenHadler = new JwtSecurityTokenHandler();
            string key = Environment.GetEnvironmentVariable("JWTSettings_SecretKey");

            TokenValidationParameters tokenValidationParameters = new()
            {
                ValidateAudience = false,

                ValidateIssuer = false,

                ValidateIssuerSigningKey = true,

                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(key) ?? throw new DataNotFoundCustomException("JWT's Secret Mode property is not set in environment or not found")),

                ValidateLifetime = false
            };

            //var tokenReader = tokenHadler.ReadJwtToken(token);
            //nếu secret key hợp lệ thì trả về claims chứa thông tin đã encode trong lúc tạo accesstoken
            return tokenHadler.ValidateToken(token, tokenValidationParameters, out _);
        }
    }
}
